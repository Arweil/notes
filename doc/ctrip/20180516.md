# 0516版本总结
这个迭代进行了代理合同结构化的编写，主要用于定制师和系统管理员为订单创建合同

## 跨域问题处理
基于上一次在imvc框架开发失败，所以这次我们干脆不在使用服务端渲染，直接把项目变成SPA进行开发

对于之前的项目我们可能使用fiddler把脚本代理到fat环境进行联调，非常麻烦。最关键的是我的个人MAC竟然无法使用charles抓取fat环境下面的文件。经过一大圈的询问得出的结论是个人PC没有权限，因为PC没有加入公司的域，可能还要进行一大堆的权限申请，更加麻烦。然而公司又不提供MAC开发。

所以，考虑自己开node服务，来进行一次请求转发。值得欣慰的是，*react-imvc*提供了node端的一些操作接口，所以我在接口中进行了一个环境判断用来处理fat的请求转发。

当然这还有cookie的问题，解决很简单，配置host到与fat环境相同域即可。

最后开发环境的请求流程应该是这样的：

*客户端发起请求(携带cookie) => node端匹配此请求的路由 => 重新向fat环境发出请求(携带cookie) => fat环境下接口返回数据 => node端response data => 客户端接收到数据*

## API模块的封装
在之前的开发中，我发现了一些问题，那就是接口返回的数据结构不统一，这导致了如果我在逻辑层调用接口可能需要写一堆判断来处理接口的异常。而且页面之间接口逻辑的重复利用率很低。如果不对接口层进行一个良好的封装，也许我以后会进入无限的复制粘贴，并且无法处理接口返回数据结构的变更。

首先我们要了解我们将要用到的框架[react-imvc](https://github.com/Lucifier129/react-imvc)。这个框架要求我们从react-imvc/controller中继承出一个页面controller子类，然后创建View层（视图层）和Model层（数据处理层）。然后统一在Controller中处理。

所以很容易想到，我们应该在自己页面的*controller*和*react-imvc/controller*中创建一个中间层，用来处理公共的内容，比如：权限校验，页面参数校验，基本信息获取和我们将要提到的API模块等。

```javascript
// BaseController.js
import Controller from 'react-imvc/controller'
export default class BaseController extends Controller {
  // common code
  // 权限校验 用户数据处理
  // 页面参数校验
  // ...
}
```

```javascript
// MyPageController.js
import View from './View'
import Model from './Model'
import BaseController from '../CommonPath/BaseController.js'

export default class MyPageController extends BaseController {
  this.View = View
  this.Model = Model
}
```

对于是使用继承来完成API模块还是组合的方式来处理，这里我选择了组合的方式。原因如下：
1. *react-imvc*提供了请求接口（post，get，fetch），对于API类中，我可以再对请求接口进行重写，保证了*react-imvc*中接口的纯净。
2. 符合设计模式的原则，场景中如果即可以使用组合也可以使用继承，那么使用组合的方式。因为，这样不会使代码进行N多的类层次，代码的依赖性也不会太高。

```javascript
// API.js
export default class API {
  constructor ({ nativeGet, nativePost, runtimeEnv }) {
    this.nativeGet = nativeGet // react-imvc get api
    this.nativePost = nativePost // react-imvc post api
    this.runtimeEnv = runtimeEnv // 获取当前运行环境 beta | preview | online 进行域名拼接之类的
  }

  _post () {
    // rewrite native post
  }

  _get () {
    // rewrite native get
  }
}
```

```javascript
// BaseController.js
import Controller from 'react-imvc/controller'
import API from './API'

export default class BaseController extends Controller {
  api = new API({
    env: this.context.env,
    post: this.post.bind(this),
    get: this.get.bind(this)
  })
  // common code
  // 权限校验 用户数据处理
  // 页面参数校验
  // ...
}
```

```javascript
// MyPageController.js
import View from './View'
import Model from './Model'
import BaseController from '../CommonPath/BaseController.js'

export default class MyPageController extends BaseController {
  this.View = View
  this.Model = Model

  requestAPI () {
    return this.api.apiName().then(() => {
      return Promise.resolve()
    })
  }
}
```

在我们对接口进行统一封装，并且返回统一内容之后又会遇到另外一个问题，那就是接口这个类（class API）会越来越大，如何对代码进行拆分。
我依旧希望我拆分的代码能够以组合的方式引用进来，并且代码使用当前的作用域的 *_post*， *_get* 方法，代码如下：
```javascript
// OrderAPI.js
export default {
  OrderAPI1 () {},
  OrderAPI2 () {},
  // ...
}
```

```javascript
// API.js
import OrderAPI from './OrderAPI.js'
export default class API {
  constructor () {
    this.combineAPI(OrderAPI)
  }
  /**
   * 使用此函数对API类进行拓展
   * 1. 可以在controller中进行拓展
   *  exp:
   *    声明: 
   *      this.api.combineAPI({ makeRequestFun () {} })
   *    调用:
   *      this.api.makeRequestFun()
   * 2. 在此API类中进行拓展，分文件
   *  exp:
   *    声明:
   *      this.combineAPI({ makeRequestFun () {} })
   *    调用: (controller)
   *      this.api.makeRequestFun()
   */
  combineAPI (apiObj) {
    const _toString = Object.prototype.toString
    if (_toString.call(apiObj) === '[object Object]') {
      Object.keys(apiObj).forEach((item) => {
        const fun = apiObj[item]
        if (_toString.call(fun) === '[object Function]') {
          this[item] = fun.bind(this)
        }
      })
    }
  }
}
```

## 规范commit说明
在提测阶段，我对代码进行了一些优化，导致结构的一些变更。时间一长，跟着bug一起提交了，没有通知测试去测，结果出了一个bug，导致了线上问题。

所以思考如何预防此类问题，我决定在提测阶段使用*Commitizen*[传送门 VSCode可以直接下载此插件](https://github.com/commitizen/cz-cli)进行代码提交内容的提醒，*Commitizen*已经应用在AngularJS的团队中。*Commitizen*指在`git commit`操作中进行一个提示，让你把备注写的更加规范和详细。我想这样就不会在下次提交代码的时候忘记提交的内容，然后忘记通知测试的同事进行测试。
